#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Indicators\Indicator.mqh>
#include <Trade\DealInfo.mqh>
#include <Trade\SymbolInfo.mqh>
#include <Thread\OrderInfo.mqh>

CDealInfo dealInfo;
CTrade trade;
CPositionInfo positionInfo;
CSymbolInfo symbolInfo;
COrderInfo orderInfo;

input group "基本参数";
input int MagicNumber = 000002;

input group "变量参数";
// 小趋势时间周期
input ENUM_TIMEFRAMES Current_Timeframe = PERIOD_M5; 
input int Current_fastMa_Period = 8; // 小趋势快线周期
input int Current_middleMa_Period = 13; // 小趋势中线周期
input int Current_slowMa_Period = 21; // 小趋势慢线周期
// 大趋势时间周期
input ENUM_TIMEFRAMES Trend_Ma_Timeframe = PERIOD_H1; 
input int Trend_fastMa_Period = 8; // 大趋势快线周期
input int Trend_slowMa_Period = 21;

input int BarCount = 10; // 获取最近多少根K线
input int tpCount = 1; // 止盈倍数


input group "其他参数";
input bool inpDisplayDebugInfoScreen = true; // 是否显示调试信息
input color inpDisplayDebugInfoColor = clrRed; // 调试信息颜色

int trendFastMaHandle; // 大趋势快线指标句柄
double trendFastMaBuffer[]; // 大趋势快线指标缓冲区
int trendSlowMaHandle; // 大趋势慢线指标句柄
double trendSlowMaBuffer[]; // 大趋势慢线指标缓冲区

int currentFastMaHandle; // 小趋势快线指标句柄
double currentFastMaBuffer[]; // 小趋势快线指标缓冲区
int currentMiddleMaHandle; // 小趋势中线指标句柄
double currentMiddleMaBuffer[]; // 小趋势中线指标缓冲区
int currentSlowMaHandle; // 小趋势慢线指标句柄
double currentSlowMaBuffer[]; // 小趋势慢线指标缓冲区

int OnInit(){
    // 创建大趋势快线和慢线指标句柄
    trendFastMaHandle = iMA(_Symbol, Trend_Ma_Timeframe, Trend_fastMa_Period, 0, MODE_EMA, PRICE_CLOSE);
    trendSlowMaHandle = iMA(_Symbol, Trend_Ma_Timeframe, Trend_slowMa_Period, 0, MODE_EMA, PRICE_CLOSE);
    currentFastMaHandle = iMA(_Symbol, Current_Timeframe, Current_fastMa_Period, 0, MODE_EMA, PRICE_CLOSE);
    currentMiddleMaHandle = iMA(_Symbol, Current_Timeframe, Current_middleMa_Period, 0, MODE_EMA, PRICE_CLOSE);
    currentSlowMaHandle = iMA(_Symbol, Current_Timeframe, Current_slowMa_Period, 0, MODE_EMA, PRICE_CLOSE);
    // 设置缓冲区
    ArraySetAsSeries(trendFastMaBuffer, true);
    ArraySetAsSeries(trendSlowMaBuffer, true);
    ArraySetAsSeries(currentFastMaBuffer, true);
    ArraySetAsSeries(currentMiddleMaBuffer, true);
    ArraySetAsSeries(currentSlowMaBuffer, true);

    trade.SetExpertMagicNumber(MagicNumber); // 设置交易魔术号

    return(INIT_SUCCEEDED);
}


void OnTick(){
    //每根Bar的openPrice执行一次
    int bars = iBars(_Symbol, Current_Timeframe);
    static int prevBars = 0;
    if(bars == prevBars) {
        return; // 如果没有新的Bar，则不执行
    }
    prevBars = bars;

    // 获取指标值
    CopyBuffer(trendFastMaHandle, 0, 0, 2, trendFastMaBuffer);
    CopyBuffer(trendSlowMaHandle, 0, 0, 2, trendSlowMaBuffer);
    CopyBuffer(currentFastMaHandle, 0, 0, 2, currentFastMaBuffer);
    CopyBuffer(currentMiddleMaHandle, 0, 0, 2, currentMiddleMaBuffer);
    CopyBuffer(currentSlowMaHandle, 0, 0, 2, currentSlowMaBuffer);

    int trendDirection = GetTrendDirection(); // 获取大级别趋势方向
    int currentDirection = GetCurrentDirection(); // 获取小级别趋势方向
    int finalDirection = trendDirection == 1 && currentDirection == 1 ? 1 : trendDirection == -1 && currentDirection == -1 ? -1 : 0; // 确定最终交易方向

    // 显示调试信息
    string debugInfo[9];
    debugInfo[0] = "大趋势快线: " + (string)trendFastMaBuffer[1];
    debugInfo[1] = "大趋势慢线: " + (string)trendSlowMaBuffer[1];
    debugInfo[2] = "当前大趋势方向: " + (string)(trendDirection == 1 ? "上升" : (trendDirection == -1 ? "下降" : "无趋势"));
    debugInfo[3] = "小趋势快线: " + (string)currentFastMaBuffer[1];
    debugInfo[4] = "小趋势中线: " + (string)currentMiddleMaBuffer[1];
    debugInfo[5] = "小趋势慢线: " + (string)currentSlowMaBuffer[1];
    debugInfo[6] = "当前小趋势方向: " + (string)(currentDirection == 1 ? "上升" : (currentDirection == -1 ? "下降" : "无趋势"));
    debugInfo[7] = "最终交易方向: " + (string)(finalDirection == 1 ? "上升" : (finalDirection == -1 ? "下降" : "无趋势"));
    debugInfo[8] = '----------------------------------------------------------------------------------------';

    // 是否显示调试信息
    if(inpDisplayDebugInfoScreen) {
        DisplayDebugInfoScreen(debugInfo);
    }

    //删除挂单
    if(trendDirection == 1 || currentDirection ==1 || trendDirection == 0 || currentDirection == 0){
        for(int i = OrdersTotal() - 1; i >= 0; i--){
            if(orderInfo.SelectByIndex(i)){
                if(orderInfo.Magic() == MagicNumber && (orderInfo.OrderType() == ORDER_TYPE_BUY_STOP || orderInfo.OrderType() == ORDER_TYPE_SELL_STOP)){
                    trade.OrderDelete(orderInfo.Ticket());
                }
            }
        }
    }

    double closePrice = iClose(_Symbol, Current_Timeframe, 0); // 获取当前收盘价
    doule highPrice = iHigh(_Symbol, Current_Timeframe, 0); // 获取当前最高价
    double lowPrice = iLow(_Symbol, Current_Timeframe, 0); // 获取当前最低价

    //接触均线，产生多单信号
    double touchLowEMA = lowPrice < currentFastMaBuffer[1] && closePrice > currentSlowMaBuffer[1];
    if(finalDirection == 1 && touchLowEMA){
        Print("挂突破单, Buy");

        //突破单价格
        double orderHighPrice = getHighPrice(); // 获取当前时间周期的最高价
        orderHighPrice = NormalizeDouble(orderHighPrice + 3 * _Point, _Digits); // 调整价格，避免滑点
        //是否产生新信号的突破单
        ulong buyOrderTid = 0;
        for(int i = OrdersTotal() - 1; i >= 0; i--){
            if(orderInfo.SelectByIndex(i)){
                if(orderInfo.Magic() == MagicNumber && orderInfo.OrderType() == ORDER_TYPE_BUY_STOP && orderInfo.PriceOpen() != orderHighPrice){
                    trade.OrderDelete(orderInfo.Ticket());
                    break;
                }
                buyOrderTid = orderInfo.Ticket();
            }
        }

        if(buyOrderTid == 0) {
            //止盈
            double takeProfitPrice = orderHighPrice + (orderHighPrice - lowPrice) * tpCount; // 止盈价格
            trade.BuyStop(0.1, orderHighPrice, _Symbol, lowPrice - 3 * _Point, takeProfitPrice, ORDER_TIME_GTC, 0, "突破单");
        }
    }

    //接触均线，产生空单信号
    double touchHighEMA = highPrice > currentFastMaBuffer[1] && closePrice < currentSlowMaBuffer[1];
    if(finalDirection == -1 && touchHighEMA){
        Print("挂突破单, Sell");

        //突破单价格
        double orderLowPrice = getLowPrice(); // 获取当前时间周期的最低价
        orderLowPrice = NormalizeDouble(orderLowPrice - 3 * _Point, _Digits); // 调整价格，避免滑点

        //是否产生新信号的突破单
        ulong sellOrderTid = 0;
        for(int i = OrdersTotal() - 1; i >= 0; i--){
            if(orderInfo.SelectByIndex(i)){
                if(orderInfo.Magic() == MagicNumber && orderInfo.OrderType() == ORDER_TYPE_SELL_STOP && orderInfo.PriceOpen() != orderLowPrice){
                    trade.OrderDelete(orderInfo.Ticket());
                    break;
                }
                sellOrderTid = orderInfo.Ticket();
            }
        }

        if(sellOrderTid == 0) {
            //止盈
            double takeProfitPrice = orderLowPrice - (highPrice - orderLowPrice) * tpCount; // 止盈价格
            trade.SellStop(0.1, orderLowPrice, _Symbol, highPrice + 3 * _Point, takeProfitPrice, ORDER_TIME_GTC, 0, "突破单");
        }
    }
}

double getHighPrice() {
    int val_index = iHighest(_Symbol, Current_Timeframe,MODE_HIGH,BarCount,1); // 获取当前时间周期的最高价索引
    if(val_index != -1){
        return iHigh(_Symbol, Current_Timeframe, val_index); // 返回最高价
    }
    return 0.0; // 如果没有找到最高价，返回0
}

double getLowPrice() {
    int val_index = iLowest(_Symbol, Current_Timeframe,MODE_LOW,BarCount,1); // 获取当前时间周期的最低价索引
    if(val_index != -1){
        return iLow(_Symbol, Current_Timeframe, val_index); // 返回最低价
    }
    return 0.0; // 如果没有找到最低价，返回0
}

//定义得到小级别趋势信息的方法
int GetCurrentDirection() {
    int result = 0; // 默认无趋势
    double closePrice = iClose(_Symbol, Current_Timeframe, 0); // 获取当前收盘价
    if (currentFastMaBuffer[1] > currentMiddleMaBuffer[1] && currentMiddleMaBuffer[1] > currentSlowMaBuffer[1]) {
        result = 1; // 上升趋势
    } else if (currentFastMaBuffer[1] < currentMiddleMaBuffer[1] && currentMiddleMaBuffer[1] < currentSlowMaBuffer[1]) {
        result = -1; // 下降趋势
    }
    return result;
}

//定义得到大级别趋势信息的方法
int GetTrendDirection() {
    int result = 0; // 默认无趋势
    double closePrice = iClose(_Symbol, Trend_Ma_Timeframe, 0); // 获取当前收盘价
    if (trendFastMaBuffer[1] > trendSlowMaBuffer[1] && closePrice > trendSlowMaBuffer[1]) {
        result = 1; // 上升趋势
    } else if (trendFastMaBuffer[1] < trendSlowMaBuffer[1] && closePrice < trendSlowMaBuffer[1]) {
        result = -1; // 下降趋势
    }
    return result;
}

void DisplayDebugInfoScreen(string &debugInfo[], int startLine = 0) {
    int lineCount = ArraySize(debugInfo);

    //删除之前的调试信息
    for(int i = 0; i < lineCount; i++) {
        string oldLabelName = "DebugInfo_" + IntegerToString(startLine + i);
        ObjectDelete(0, oldLabelName);
    }

    // 显示新的调试信息
    for(int i = 0; i < lineCount; i++) {
        string labelName = "DebugInfo_" + IntegerToString(startLine + i);
        if(ObjectCreate(0, labelName, OBJ_LABEL, 0, 0, 0)) {
            ObjectSetInteger(0, labelName, OBJPROP_TEXT, debugInfo[i]);
            ObjectSetInteger(0, labelName, OBJPROP_XDISTANCE, 50);
            ObjectSetInteger(0, labelName, OBJPROP_YDISTANCE, 50 + (startLine + i)* 20);
            ObjectSetInteger(0, labelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
            ObjectSetInteger(0, labelName, OBJPROP_COLOR, inpDisplayDebugInfoColor);
        }
    }
}
