#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Indicators\Indicator.mqh>
#include <Trade\DealInfo.mqh>
#include <Trade\SymbolInfo.mqh>

CDealInfo m_deal;
CTrade trade;
CPositionInfo m_position;
CSymbolInfo m_symbol;

input group "基本参数";
input int MagicNumber = 123456; // EA的魔术号
input double InitialLot = 0.01; // 初始化手数
input int MaxSpread = 10; // 最大允许点差
input int MaxSlippage = 3; // 最大滑点

input group "参数优化";
input int Rsi_Period = 14; // RSI周期
input int RSILevel = 80; // RSI上沿值
input int BarsForCondition = 20; // 比较n根K线的RSI
input int TakeProfit = 300; // 止盈点数
input int StopLoss = 100; // 止损点数
input double MartingaleMultiplier = 2.0; // 反向时增加n倍手数

input group "时间过滤器";
input int StartTime = 1; // 开始交易时间小时
input int EndTime = 23; // 结束交易时间小时
input bool Hour_00 = false; // 暂停交易时间段：00:00 - 00:59
input bool Hour_01 = false; // 暂停交易时间段：01:00 - 01:59
input bool Hour_02 = false; // 暂停交易时间段：02:00 - 02:59
input bool Hour_03 = false; // 暂停交易时间段：03:00 - 03:59
input bool Hour_04 = false; // 暂停交易时间段：04:00 - 04:59
input bool Hour_05 = false; // 暂停交易时间段：05:00 - 05:59
input bool Hour_06 = false; // 暂停交易时间段：06:00 - 06:59
input bool Hour_07 = false; // 暂停交易时间段：07:00 - 07:59
input bool Hour_08 = false; // 暂停交易时间段：08:00 - 08:59
input bool Hour_09 = false; // 暂停交易时间段：09:00 - 09:59
input bool Hour_10 = false; // 暂停交易时间段：10:00 - 10:59
input bool Hour_11 = false; // 暂停交易时间段：11:00 - 11:59
input bool Hour_12 = false; // 暂停交易时间段：12:00 - 12:59
input bool Hour_13 = false; // 暂停交易时间段：13:00 - 13:59
input bool Hour_14 = false; // 暂停交易时间段：14:00 - 14:59
input bool Hour_15 = false; // 暂停交易时间段：15:00 - 15:59
input bool Hour_16 = false; // 暂停交易时间段：16:00 - 16:59
input bool Hour_17 = false; // 暂停交易时间段：17:00 - 17:59
input bool Hour_18 = false; // 暂停交易时间段：18:00 - 18:59
input bool Hour_19 = false; // 暂停交易时间段：19:00 - 19:59
input bool Hour_20 = false; // 暂停交易时间段：20:00 - 20:59
input bool Hour_21 = false; // 暂停交易时间段：21:00 - 21:59
input bool Hour_22 = false; // 暂停交易时间段：22:00 - 22:59
input bool Hour_23 = false; // 暂停交易时间段：23:00 - 23:59

input group "其他参数";
input bool inpDisplayDebugInfoScreen = true; // 是否显示调试信息
input color inpDisplayDebugInfoColor = clrBlack; // 调试信息颜色

int rsi_handle; // RSI指标句柄
double rsi_Buffer[]; // RSI缓冲区

int OnInit(){
   if(StartTime >= EndTime) {
        Print("错误：开始时间或结束时间设置不正确。");
        return(INIT_PARAMETERS_INCORRECT);
    }
    //创建rsi指标句柄
   rsi_handle = iRSI(_Symbol, 0, Rsi_Period, PRICE_CLOSE);
   
   //数组设为时序上的倒序
   ArraySetAsSeries(rsi_Buffer, true);
   trade.SetExpertMagicNumber(MagicNumber);
   return(INIT_SUCCEEDED);
}
void OnDeinit(const int reason)
  {
  }
  
void OnTick(){
    //从指标缓冲区获取数据并存储到动态数组中
  iGetArray(rsi_handle, 0, 0, BarsForCondition+1, rsi_Buffer);

  //调试信息
  string debugInfo[9];
  debugInfo[0] = "当前RSI: " + DoubleToString(rsi_Buffer[0],2);
  debugInfo[1] = "做多信号:" + (CheckBuyCondition() ? "True" : "False");
  debugInfo[2] = "做空信号:" + (CheckSellCondition() ? "True" : "False");
  debugInfo[3] = "当前时间是否允许交易: " + (IsTradeAllowed() ? "True" : "False");
  //获取最后一笔交易的信息
  ENUM_DEAL_TYPE closedDealType;
  double lastNegativeDealProfit;
  double lastNegativeDealLot;
  isLastPositionNegative(_Symbol, closedDealType, lastNegativeDealProfit, lastNegativeDealLot);
  debugInfo[4] = "最后一笔交易类型: " + EnumToString(closedDealType) + ", 利润: " + DoubleToString(lastNegativeDealProfit, 2) + ", 手数: " + DoubleToString(lastNegativeDealLot, 2);

  debugInfo[8] = "--------------------------------------------";
  
 
  //是否显示调试信息
  if(inpDisplayDebugInfoScreen) {
    DisplayDebugInfo(debugInfo);
  }

  //检查当前时间是否允许交易
  if(!IsTradeAllowed() || IsTradeTimeAllowed()) {
    Print("当前时间不允许交易,EA将暂停操作。");
    return;
  }

  //检查手数
  double Lot = LotCheck(InitialLot);
  if(Lot <= 0) {
    Print("错误:手数不符合要求,EA将暂停操作。");
    return;
  }

  //rsi是最近几根k的最小值而且当前没有多单持仓
  if(CheckBuyCondition() && !IsBuyPositionExists() && currentRSI < (100 - RSILevel)) {
    //开多单
    OpenBuy(Lot);
  }
  //rsi是最近几根k的最大值而且当前没有空单持仓
  if(CheckSellCondition() && !IsSellPositionExists() && currentRSI > RSILevel) {
    //开空单
    OpenSell(Lot);
  }
}

//当上一笔交易亏损时，开一个反向单
bool OpenReversePosition() {
  ENUM_DEAL_TYPE closedDealType;
  double lastNegativeDealProfit;
  double lastNegativeDealLot;
  isLastPositionNegative(_Symbol, closedDealType, lastNegativeDealProfit, lastNegativeDealLot);

  double Lot;

  if(lastNegativeDealProfit < 0) {
    double newLot = lastNegativeDealLot * MartingaleMultiplier;
    if(!IsPositionWithSameVolumeOpen(newLot)) {
      Lot = LotCheck(newLot);
      if(Lot == 0.0){
        Print(__FILE__, ":", __FUNCTION__, " - 错误:手数不符合要求, EA将暂停操作。");
        return false;
      }
      OpenBuy(Lot); // 开多单
      return true;
    } else if(closedDealType == DEAL_TYPE_SELL) {
      Lot = LotCheck(lastNegativeDealLot);
      if(Lot == 0.0){
        Print(__FILE__, ":", __FUNCTION__, " - 错误:手数不符合要求, EA将暂停操作。");
        return false;
      }
      OpenSell(Lot); // 开空单
      return true;
    }
  }
  return false; // 没有满足开反向单的条件  
}

//检查是否存在相同手数的持仓
bool IsPositionWithSameVolumeOpen(double lot) {
  for(int i = 0, i < PositionsTotal(); i++) {
    if(positionInfo.SelectByIndex(i)) {
      if(StringFind(positionInfo.Symbol(), _Symbol) != -1 && positionInfo.Magic() == MagicNumber && positionInfo.Volume() == lot) {
        Print("存在相同手数的持仓");
        return true; // 存在相同手数的持仓
      }
  }
  return false; // 没有找到相同手数的持仓
}

//检查最后一笔交易是否为负
bool isLastPositionNegative(string symbol, ENUM_DEAL_TYPE & closedDealType, double &lastNegativeDealProfit, double &lastNegativeDealLot) {
  datetime from_date = TimeCurrent() - 60 * 60 * 24; // 获取过去24小时的交易
  datetime to_date = TimeCurrent() + 60 * 60 * 24; // 获取未来24小时的交易
  HistorySelect(from_date, to_date);

  int total_deals = HistoryDealsTotal();
  ulong ticket_history_deal = 0;

  for(int i = total_deals - 1; i >= 0; i--) {
    if((ticket_history_deal = HistoryDealGetTicket(i)) > 0) {
      if(m_deal.SelectByIndex(i)){
        if(m_deal.Symbol() == symbol && m_deal.Magic() == MagicNumber && m_deal.Entry() == DEAL_ENTRY_OUT) {
          lastNegativeDealProfit = m_deal.Profit();
          closedDealType = m_deal.DealType();
          Print("最后一笔交易类型: ", closedDealType, ", 利润: ", lastNegativeDealProfit);
          lastNegativeDealLot = m_deal.Volume();

          return true;
        }
      }
    }
 }
 return false; // 没有找到符合条件的交易
}

//开多单
void OpenBuy(double lot) {
  double ask;
  long spread;

  if(!SymbolInfoDouble(_Symbol, SYMBOL_ASK, ask) || !SymbolInfoInteger(_Symbol, SYMBOL_SPREAD, spread)) {
    Print("获取当前品种信息失败");
    return;
  }

  if(MaxSpread > 0 && spread > MaxSpread) {
    PrintFormat("错误:当前点差超过最大允许点差, EA: %s, 方法: %s, 错误代码: %d", __FILE__, __FUNCTION__, __LINE__);
    return;
  }

  //设置止损和止盈
  double takeProfitPrice = 0.0;
  double stopLossPrice = 0.0;
  if(TakeProfit > 0) {
    takeProfitPrice = NormalizeDouble(ask + TakeProfit * _Point, _Digits);
  }
  if(StopLoss > 0) {
    stopLossPrice = NormalizeDouble(ask - StopLoss * _Point, _Digits);
}

  if(trade.Buy(lot, _Symbol, 0, 0, takeProfitPrice, stopLossPrice)) {
    Print("开多单成功，手数: ", lot);
  } else {
    Print("开多单失败，错误代码: ", GetLastError());
  }
}

//开空单
void OpenSell(double lot) {
  double bid;
  long spread;

  if(!SymbolInfoDouble(_Symbol, SYMBOL_BID, bid) || !SymbolInfoInteger(_Symbol, SYMBOL_SPREAD, spread)) {
    Print("获取当前品种信息失败");
    return;
  }

  if(MaxSpread > 0 && spread > MaxSpread) {
    PrintFormat("错误:当前点差超过最大允许点差, EA: %s, 方法: %s, 错误代码: %d", __FILE__, __FUNCTION__, __LINE__);
    return;
  }

  //设置止损和止盈
  double takeProfitPrice = 0.0;
  double stopLossPrice = 0.0;
  if(TakeProfit > 0) {
    takeProfitPrice = NormalizeDouble(bid - TakeProfit * _Point, _Digits);
  }
  if(StopLoss > 0) {
    stopLossPrice = NormalizeDouble(bid + StopLoss * _Point, _Digits);
  }

  if(trade.Sell(lot, _Symbol, 0, 0, takeProfitPrice, stopLossPrice)) {
    Print("开空单成功，手数: ", lot);
  } else {
    Print("开空单失败，错误代码: ", GetLastError());
  }
}

//是否存在多单持仓
bool IsBuyPositionExists() {
  int totalPositions = PositionsTotal();
  for(int i = totalPositions - 1; i >= 0; i--) {
    ulong positionTicket = PositionGetTicket(i);
    if(positionTicket <= 0) {
      PrintFormat("错误:获取持仓票据失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return false;
    }

    if(!PositionSelectByTicket(positionTicket)) {
      PrintFormat("错误:选择持仓失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return false;
    }

    long magic; if(!PositionGetInteger(POSITION_MAGIC, magic)) {
      PrintFormat("错误:获取持仓魔术号失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return false;
    }

    if(magic == MagicNumber){
      long type; if(!PositionGetInteger(POSITION_TYPE, type)) {
        PrintFormat("错误:获取持仓类型失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
        return false;
      }
      if(type == POSITION_TYPE_BUY) {
        Print("存在多单持仓,EA将暂停操作。");
        return true; // 存在多单持仓
      }
    }

    return false;
  }
}

//是否存在空单持仓
bool IsSellPositionExists() {
  int totalPositions = PositionsTotal();
  for(int i = totalPositions - 1; i >= 0; i--) {
    ulong positionTicket = PositionGetTicket(i);
    if(positionTicket <= 0) {
      PrintFormat("错误:获取持仓票据失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return false;
    }
    if(!PositionSelectByTicket(positionTicket)) {
      PrintFormat("错误:选择持仓失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return false;
    }
    long magic; if(!PositionGetInteger(POSITION_MAGIC, magic)) {
      PrintFormat("错误:获取持仓魔术号失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return false;
    }
    if(magic == MagicNumber){
      long type; if(!PositionGetInteger(POSITION_TYPE, type)) {
        PrintFormat("错误:获取持仓类型失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
        return false;
      }
      if(type == POSITION_TYPE_SELL) {
        Print("存在空单持仓,EA将暂停操作。");
        return true; // 存在空单持仓
      }
    }

    return false;
  }
}

//检查手数是否符合要求
double LotCheck(double lots) {
  double volume = NormalizeDouble(lots, 2);
  double stepvol = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
  if(stepvol > 0.0) {
    volume = stepvol * MathFloor(volume / stepvol);
  }

  double minvol = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
  if(volume < minvol) {
    Print("错误：手数小于最小手数，调整为最小手数: ", minvol);
  }

  double maxvol = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
  if(volume > maxvol) {
    volume = maxvol;
  }

  return volume;
}

//禁止在某些时间段内交易
bool IsTradeTimeAllowed() {
  datetime currentTime = TimeCurrent();
  MqlDateTime currentDateTime;
  TimeToStruct(currentTime, currentDateTime);
  bool hoursToAvoid[24] = {
    Hour_00, Hour_01, Hour_02, Hour_03, Hour_04, Hour_05,
    Hour_06, Hour_07, Hour_08, Hour_09, Hour_10, Hour_11,
    Hour_12, Hour_13, Hour_14, Hour_15, Hour_16, Hour_17,
    Hour_18, Hour_19, Hour_20, Hour_21, Hour_22, Hour_23
  };

  //检查当前时间是否允许交易
  if(hoursToAvoid[currentDateTime.hour]) {
    Print("当前时间不允许交易: ", currentDateTime.hour);
    return true;
  } 

  return false;
}

//检查当前时间是否允许交易
bool IsTradeAllowed() {
  datetime currentTime = TimeCurrent();
  MqlDateTime currentDateTime;
  TimeToStruct(currentTime, currentDateTime);
  int currentHour = currentDateTime.hour;
  //检查当前时间是否在允许交易的时间段内
  if ((currentHour >= StartTime && currentHour <= EndTime){
    return true;
  }

  Print("当前时间不允许交易: ", currentHour);
  return false;
}

//做多信号
bool CheckBuyCondition(){
  bool isMinRSI = IsMinRSIForBars();
  if(isMinRSI){
    return true;
  }

  return false;
}


//做空信号
bool CheckSellCondition(){
  bool isMaxRSI = IsMaxRSIForBars();
  if(isMaxRSI){
    return true;
  }

  return false;
}

//检查是否满足做多条件:最近几根k线的最小rsi
bool IsMinRSIForBars(){
   double current_rsi = rsi_Buffer[0];
   bool isMinRSI = true;

   for(int i = 1; i < BarsForCondition; i++){
    if(current_rsi > rsi_Buffer[i]){
        isMinRSI = false;
        break;
    }
  }


  return isMinRSI;
}


//检查是否满足做空条件:最近几根k线的最大rsi
bool IsMaxRSIForBars(){
   double current_rsi = rsi_Buffer[0];
   bool isMaxRSI = true;

   for(int i = 1; i < BarsForCondition; i++){
    if(current_rsi < rsi_Buffer[i]){
        isMaxRSI = false;
        break;
    }
  }

  return isMaxRSI;
}
  
//从指标缓冲区中获取数据并存储到动态数组 arr_buffer中
//const常量参数，函数内部不可修改
bool iGetArray(const int handle, const int buffer,const int start_por,const int count, double &arr_buffer[]){
   bool result = true;

   //检查数组是否为动态数组
   if(!ArrayIsDynamic(arr_buffer)){
      Print("错误：传入的数组不是动态数组。");
      return false;
   }

   //释放数组内存
   ArrayFree(arr_buffer);

   //重置错误代码
    ResetLastError();
   //从指标缓冲区复制一部分数据到数组中
   int copied = CopyBuffer(handle, buffer, start_por, count, arr_buffer);
   if(copied != count){
      //如果复制的数据量不等于请求的数量，打印错误信息
      int error_code = GetLastError();
      Print("错误：CopyBuffer() 失败，错误代码：", error_code);
      result = false;
   } else {
      Print("成功从指标缓冲区复制数据，复制数量：", copied);
}

  return result;

}

void DisplayDebugInfo(string &debugLine[], int startLine = 0) {
  int lineCount = ArraySize(debugLine);

  //删除上一次生成的信息
  for(int i = 0; i < lineCount; i++) {
    string oldLabelName = "DebugInfo_" + IntegerToString(i + startLine);
    ObjectDelete(0, oldLabelName);
  }

  for(int i = 0; i < lineCount; i++) {
    string labelName = "DebugInfo_" + IntegerToString(i + startLine);
    //创建新的标签对象
    if(ObjectCreate(0, labelName, OBJ_LABEL, 0, 0, 0)) {
       ObjectSetString(0, labelName, OBJPROP_TEXT, debugLine[i]);
       ObjectSetInteger(0, labelName, OBJPROP_XDISTANCE, 50);
       ObjectSetInteger(0, labelName, OBJPROP_YDISTANCE, 50 + (startLine+i) * 20);
       ObjectSetInteger(0, labelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
       ObjectSetInteger(0, labelName, OBJPROP_COLOR, inpDisplayDebugInfoColor);
    }
  }
}


//平多仓
void CloseBuy(double currentRSI){
  int totalPositions = PositionsTotal();
  for(int i = totalPositions - 1; i >= 0; i--) {
    ulong positionTicket = PositionGetTicket(i);
    if(positionTicket <= 0) {
      PrintFormat("错误:获取持仓票据失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return;
    }
    if(!PositionSelectByTicket(positionTicket)) {
      PrintFormat("错误:选择持仓失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return;
    }
    long magic; 
    if(!PositionGetInteger(POSITION_MAGIC, magic)) {
      PrintFormat("错误:获取持仓魔术号失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return;
    }
    if(magic == MagicNumber){
      long type; 
      if(!PositionGetInteger(POSITION_TYPE, type)) {
        PrintFormat("错误:获取持仓类型失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
        return;
      }
      if(type == POSITION_TYPE_SELL) {
        continue;
      }
      trade.PositionClose(positionTicket);
      if(trade.ResultRetcode() != TRADE_RETCODE_DONE) {
        PrintFormat("平多仓失败, EA: %s, 方法: %s, 错误代码: %d", __FILE__, __FUNCTION__, __LINE__);
        return; 
      }

      Print("平多仓成功" + _Symbol + "RSI: " + DoubleToString(currentRSI, 2) + ", 手数: " + DoubleToString(PositionGetDouble(POSITION_VOLUME), 2));
    }
  }
}

//平空仓
void CloseSell(double currentRSI){
  int totalPositions = PositionsTotal();
  for(int i = totalPositions - 1; i >= 0; i--) {
    ulong positionTicket = PositionGetTicket(i);
    if(positionTicket <= 0) {
      PrintFormat("错误:获取持仓票据失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return;
    }
    if(!PositionSelectByTicket(positionTicket)) {
      PrintFormat("错误:选择持仓失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return;
    }
    long magic; 
    if(!PositionGetInteger(POSITION_MAGIC, magic)) {
      PrintFormat("错误:获取持仓魔术号失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
      return;
    }
    if(magic == MagicNumber){
      long type; 
      if(!PositionGetInteger(POSITION_TYPE, type)) {
        PrintFormat("错误:获取持仓类型失败, EA: %s, 方法: %s, 错误代码: %d",__FILE__, __FUNCTION__, __LINE__);
        return;
      }
      if(type == POSITION_TYPE_SELL) {
        continue;
      }
      trade.PositionClose(positionTicket);
      if(trade.ResultRetcode() != TRADE_RETCODE_DONE) {
        PrintFormat("平空仓失败, EA: %s, 方法: %s, 错误代码: %d", __FILE__, __FUNCTION__, GetLastError());
        return; 
      }

      Print("平空仓成功" + _Symbol + "RSI: " + DoubleToString(currentRSI, 2) + ", 手数: " + DoubleToString(PositionGetDouble(POSITION_VOLUME), 2));
    }
  }
}
